`timescale 1ns / 1ps

module tb_mult8x8;

    // Clock
    reg clk;
    
    // Inputs
    reg [7:0] A, B;

    // Output
    wire [15:0] P;

    // Instantiate the accurate or approximate multiplier
    mult8x8_accurate uut (
        .A(A),
        .B(B),
        .P(P)
    );

    // Reference output
    reg [15:0] expected;
    integer i;

    // Clock generation â€” 10ns period
    initial clk = 0;
    always #5 clk = ~clk;

    // Test vectors
    reg [7:0] A_vec [0:16];
    reg [7:0] B_vec [0:16];

    initial begin
        // Initialize specific tests
        A_vec[0] = 0;    B_vec[0] = 0;
        A_vec[1] = 255;  B_vec[1] = 1;
        A_vec[2] = 12;   B_vec[2] = 15;
        A_vec[3] = 100;  B_vec[3] = 200;
        A_vec[4] = 50;   B_vec[4] = 5;
        A_vec[5] = 128;  B_vec[5] = 128;
        A_vec[6] = 255;  B_vec[6] = 255;

        // Random tests for remaining entries
        for (i = 7; i < 17; i = i + 1) begin
            A_vec[i] = $random;
            B_vec[i] = $random;
        end
    end

    initial begin
        $display("Clock |   A     B   | HW Result | Reference | Match?");
        $display("----------------------------------------------------");

        // Apply test vectors each cycle
        for (i = 0; i < 17; i = i + 1) begin
            @(posedge clk);
            A <= A_vec[i];
            B <= B_vec[i];

            // Let UUT compute one cycle
            @(posedge clk);
            expected = A * B;

            $display("%4d | %3d  %3d | %5d     | %5d     | %s",
                     i, A, B, P, expected,
                     (P == expected) ? "YES" : "NO");
        end

        @(posedge clk);
        $stop;
    end

endmodule
